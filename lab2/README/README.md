# Практичне заняття №2
# Завдання 1
## Формулювання завдання
Напишіть програму для визначення моменту, коли time_t закінчиться.

Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури.

Дослідіть сегменти виконуваного файлу.

## Опис виконання
Програма визначає максимальне значення типу time_t для поточної архітектури та виводить дату, коли "закінчиться" час Unix. Досліджуються відмінності між 32-бітною та 64-бітною архітектурами, включаючи проблему "Y2038 Bug". Також аналізуються сегменти виконуваного файлу для розуміння структури програми.

## Код: `2-1.c`
```
#include<stdio.h>
#include<time.h>
#include<limits.h>
int main(){
time_t max_time = (time_t)(~((time_t)1 << (sizeof(time_t)*8 -1)));
printf("Розмір time_t: %zu байтів\n", sizeof(time_t));
printf("Максимальне значення time_t: %ldd\n", (long long)max_time);
char *time_str = ctime(&max_time);
if(time_str)
    printf("Дата, яка відповідає максимальному значенню time_t: %s\n", time_str);
else
    perror("ctime");

return 0;
}
```
## Компіляція
```
cc -Wall -o 2-1 2-1.c
./2-1
```
## Результати дослідження
```
Розмір time_t: 8 байтів
Максимальне значення time_t: 9223372036854775807d
ctime: No error: 0
```
# Завдання 2.2
## Формулювання завдання
Розгляньте сегменти у виконуваному файлі.

Скомпілюйте програму "hello world", запустіть ls -l для
виконуваного файлу, щоб отримати його загальний розмір, і
запустіть size, щоб отримати розміри сегментів всередині нього.
Додайте оголошення глобального масиву із 1000 int,
перекомпілюйте й повторіть вимірювання. Зверніть увагу на
відмінності.
Тепер додайте початкове значення в оголошення масиву
(пам'ятайте, що C не змушує вас вказувати значення для кожного
елемента масиву в ініціалізаторі). Це перемістить масив із сегмента
BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на
різницю.
Тепер додайте оголошення великого масиву в локальну функцію.
Оголосіть другий великий локальний масив з ініціалізатором.
Повторіть вимірювання. Дані розташовуються всередині функцій,
залишаючись у виконуваному файлі? Яка різниця, якщо масив
ініціалізований чи ні?
Які зміни відбуваються з розмірами файлів і сегментів, якщо ви
компілюєте для налагодження? Для максимальної оптимізації?


## Опис виконання
Програма демонструє вплив глобальних і локальних масивів, ініціалізованих і неініціалізованих даних на розміри сегментів виконуваного файлу. Досліджуються відмінності між сегментами .data, .bss і .text при різних типах компіляції.
## Код: `2-2.c`
```
#include<stdio.h>

int main(){
	int local_array[1000];//неініціалізований масив
	int initialized_array[1000] = {1};//ініціалізований масив
	
	printf("Hello World!\n");
	return 0;
}
```
## Компіляція
```
cc -Wall -o 2-2 2-2.c
./2-2
```
# Завдання 2.3
## Формулювання завдання

Завдання передбачає:
Скомпілюйте й запустіть тестову програму, щоб визначити приблизне
розташування стека у вашій системі:
#include &lt;stdio.h&gt;
int main() {
int i;
printf(&quot;The stack top is near %p\n&quot;, &amp;i);
return 0;
}
Знайдіть розташування сегментів даних і тексту, а також купи всередині
сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і
виведіть їхні адреси.
Збільшіть розмір стека, викликавши функцію й оголосивши кілька
великих локальних масивів. Яка зараз адреса вершини стека?
## Опис виконання

### Частина 1: Визначення розташування стеку

Для визначення розташування стеку в системі було скомпільовано і запущено програму, яка виводить адресу локальної змінної:

```
#include <stdio.h>
int main() {
    int i;
    printf("The stack top is near %p\n", (void*)&i);
    return 0;
}
```
Результат компіляції та запуску у FreeBSD:
root@host:/home/guest/aspz_labs/lab2 # ./2-3_base_program
The stack top is near 0x820bb7bf8

Адреса показує, що стек розташований у верхній частині адресного простору (значення близькі до 0x820bb7bf8), що є типовим для FreeBSD та інших Unix-подібних систем.
Частина 2: Розташування сегментів даних, тексту та купи
Для визначення розташування різних сегментів пам'яті було написано наступну програму:
```
#include <stdio.h>
#include <stdlib.h>
int global_init = 42;               // .data (ініціалізовані глобальні)
int global_uninit;                  // .bss (неініціалізовані глобальні)
void dummy_function() {}           // розміщується в .text
int main() {
    int local_var = 1;             // стек
    static int static_var = 2;     // .data
    static int static_uninit;      // .bss
    int *heap_var = malloc(sizeof(int) * 10);  // купа (heap)
    printf("Code (.text)        is near: %p\n", (void*)&dummy_function);
    printf("Init data (.data)   is near: %p\n", (void*)&global_init);
    printf("Uninit (.bss)       is near: %p\n", (void*)&global_uninit);
    printf("Static (.data)      is near: %p\n", (void*)&static_var);
    printf("Static uninit (.bss) is near: %p\n", (void*)&static_uninit);
    printf("Heap                is near: %p\n", (void*)heap_var);
    printf("Stack (local var)   is near: %p\n", (void*)&local_var);
    free(heap_var);
    return 0;
}
```
Результат компіляції та запуску у FreeBSD:
```
root@host:/home/guest/aspz_labs/lab2 # ./2-3_advanced
Code (.text)        is near: 0x201810
Init data (.data)   is near: 0x203b38
Uninit (.bss)       is near: 0x203b94
Static (.data)      is near: 0x203b3c
Static uninit (.bss) is near: 0x203b90
Heap                is near: 0x209b27e09000
Stack (local var)   is near: 0x820884838
```
# Завдання 4
## Формулювання завдання
Ознайомтеся з виводом gstack і порівняйте його з GDB.
## Опис виконання
Код містить чотири функції з однаковою структурою: main(), foo(), bar() та bar_is_now_closed().
Кожна функція оголошує локальну змінну localvar зі значенням 5.
Кожна функція виводить своє ім'я та адресу локальної змінної, що демонструє розміщення змінних на стеку.
Функції викликають одна одну в порядку: main() -> foo() -> bar() -> bar_is_now_closed().
Остання функція bar_is_now_closed() викликає системну функцію pause(), яка блокує процес до отримання сигналу, що дозволяє нам дослідити стек процесу за допомогою GDB чи інших інструментів.
## Код: `2-4.c`
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

#define MSG "In function %20s; &localvar = %p\n"

static void bar_is_now_closed(void) {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    printf("\n Now blocking on pause()...\n");
    pause();  // Чекає сигналу, процес “засинає”
}

static void bar(void) {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    bar_is_now_closed();
}

static void foo(void) {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    bar();
}

int main(int argc, char **argv) {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    foo();
    exit(EXIT_SUCCESS);
}
```
## Компіляція
```
cc -Wall -o 2-4 2-4.c
./2-4
```
